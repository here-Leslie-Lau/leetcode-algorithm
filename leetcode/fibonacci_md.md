# 斐波纳利数列

## 题目

斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。

---

## 题解

本道题比较简单，当前值等于前两项之和，如果是第1位或者第2位直接返回1即可。这就是简单的递归：

```go
package main

func fib(n int) int {
	if n == 0 {
		return 0
	}
	if n == 1 || n == 2 {
		return 1
	}
	// 直接递归
	return fib(n-1) + fib(n-2)
}
```

但是这种解法性能上有个**大缺点**，假设我们传的值是20，那么会先计算出`fib(19)`和`fib(18)`的值，而计算`fib(19)`又需要`fib(18)`的值。

分析发现总有值会被重复计算，而且这个值计算起来还挺耗时的。

那其实可以优化一下，每一次计算的值我们都保存起来，类似与程序中经常是用的缓存一样。如果有就代表之前计算过了，如果没有则计算后在放入缓存内，减去了重复计算的烦恼。

我们上面的程序是从**原问题往下推导的**，一直递归到`fib(1)`和`fib(2)`的情况才慢慢网上返回。今天换一下，从在开始的1和2，往上推导，再加上上面的缓存优化法，代码如下:

```go
package main

func fib(n int) int {
	if n == 0 {
		return 0
	}
	if n == 1 || n == 2 {
		return 1
	}

	// 缓存数组,索引代表输入参数n，索引对应的值代表斐波纳利算法得到的答案
	cache := make([]int, n+1)
	// 初始化数组,数组第0位空出,因为输入参数0无意义
	cache[1], cache[2] = 1, 1
	for i := 3; i <= n; i++ {
		// 本项等于前两项之和,算出的值保存在数组内,供以后调用时减少重复计算
		cache[i] = cache[i-1] + cache[i-2]
	}
	return cache[n]
}
```

代码优化完了，上面说的其实类似**动态规划**的思想。有一个数组(缓存),它的目的是为了减少重复的计算(重叠子问题)

这道题还能再优化下，刚刚第二版只是优化了时间复杂度(减少重复计算操作),但是空间上还是开辟了n+1个大小的数组。其实我们只是需要前两项的数就好了，所以还可以这样写:

```go
package main

func fib(n int) int {
	if n == 0 {
		return 0
	}
	if n == 1 || n == 2 {
		return 1
	}

	pre, cur := 1, 1
	for i := 3; i <= n; i++ {
		// 本项等于前两项之和
		sum := pre + cur
		// 每一个数各前进一位
		pre = cur
		cur = sum
	}
	return cur
}
```